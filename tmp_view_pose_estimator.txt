import math
import time
from dataclasses import dataclass
from typing import Dict, List, Optional, Protocol, Tuple


@dataclass
class Rotation2d:
    radians: float

    @classmethod
    def from_degrees(cls, degrees: float) -> "Rotation2d":
        return cls(math.radians(degrees))

    def get_degrees(self) -> float:
        return math.degrees(self.radians)


@dataclass
class Translation2d:
    x: float
    y: float


@dataclass
class Pose2d:
    translation: Translation2d
    rotation: Rotation2d

    def get_x(self) -> float:
        return self.translation.x

    def get_y(self) -> float:
        return self.translation.y

    def get_rotation(self) -> Rotation2d:
        return self.rotation


class NetworkTablesInterface(Protocol):

    def get_double(self, name: str, default: float = 0.0) -> float:
        ...

    def get_double_array(self, name: str, default: List[float]) -> List[float]:
        ...


class PoseEstimator:
    LIMELIGHT_NAME = "limelight-left"
    TARGET_DISTANCE_FEET = 2.0
    ANGLE_TOLERANCE_DEGREES = 2.0
    DISTANCE_TOLERANCE_FEET = 0.3

    CAMERA_MOUNT_ANGLE_X_DEGREES = 40.0
    CAMERA_MOUNT_ANGLE_Y_DEGREES = 99.846552
    CAMERA_HEIGHT_INCHES = 9.5
    CAMERA_OFFSET_X_INCHES = 8.41
    CAMERA_OFFSET_Y_INCHES = 11.6

    def __init__(
        self,
        nt_client: NetworkTablesInterface,
        tag_layout: Optional[Dict[int, Tuple[float, float, float]]] = None,
    ) -> None:
        """
        tag_layout: map[tag_id] = (x_meters, y_meters, rotation_degrees)
        """
        self.nt_client = nt_client
        self.tag_layout = tag_layout or {}

        self.tx = 0.0
        self.ty = 0.0
        self.ta = 0.0
        self.tcornxy: List[float] = [0.0] * 8
        self.tag_id = -1
        self.last_timestamp = 0.0

    def update_from_networktables(self) -> None:
        tv = self.nt_client.get_double("tv", 0.0)
        self.tx = self.nt_client.get_double("tx", 0.0)
        self.ty = self.nt_client.get_double("ty", 0.0)
        self.ta = self.nt_client.get_double("ta", 0.0)
        self.tcornxy = self.nt_client.get_double_array("tcornxy", [0.0] * 8)
        self.tag_id = int(self.nt_client.get_double("tid", -1.0))
        if tv == 1:
            self.last_timestamp = time.time()

    def is_corners_valid(self) -> bool:
        if not self.tcornxy or len(self.tcornxy) < 8:
            return False
        return any(abs(v) > 1e-3 for v in self.tcornxy)

    def calculate_tag_area(self) -> float:
        x0, y0, x1, y1, x2, y2, x3, y3 = self.tcornxy[:8]
        h_left = abs(y3 - y0)
        h_right = abs(y2 - y1)
        w_top = abs(x2 - x3)
        w_bottom = abs(x1 - x0)
        avg_height = (h_left + h_right) / 2.0
        avg_width = (w_top + w_bottom) / 2.0
        return avg_width * avg_height

    def calculate_distance_from_area(self, area: float) -> float:
        return 12.23504 * math.pow(0.999818, area) + 1.19735

    def calculate_optimal_movement(self) -> Dict[str, float]:
        real_time_ta = self.calculate_tag_area()
        camera_distance = self.calculate_distance_from_area(real_time_ta)

        camera_offset_distance = math.hypot(
            self.CAMERA_OFFSET_X_INCHES / 12.0, self.CAMERA_OFFSET_Y_INCHES / 12.0
        )
        horizontal_angle_error = self.tx
        adjusted_camera_distance = camera_distance / math.cos(
            math.radians(self.CAMERA_MOUNT_ANGLE_Y_DEGREES)
        )

        robot_center_distance = math.sqrt(
            math.pow(adjusted_camera_distance, 2)
            + math.pow(camera_offset_distance, 2)
            - 2
            * adjusted_camera_distance
            * camera_offset_distance
            * math.cos(
                math.radians(
                    horizontal_angle_error + self.CAMERA_MOUNT_ANGLE_X_DEGREES
                )
            )
        )

        current_distance = robot_center_distance + 1.0

        forward_movement = current_distance - self.TARGET_DISTANCE_FEET
        strafe_movement = current_distance * math.tan(math.radians(horizontal_angle_error))
        rotation_required = horizontal_angle_error

        return {
            "camera_distance_feet": camera_distance,
            "robot_center_distance_feet": robot_center_distance,
            "current_distance_feet": current_distance,
            "target_distance_feet": self.TARGET_DISTANCE_FEET,
            "horizontal_angle_error_deg": horizontal_angle_error,
            "forward_feet": forward_movement,
            "strafe_feet": strafe_movement,
            "rotation_deg": rotation_required,
        }

    def generate_movement_command(
        self, forward: float, strafe: float, rotation: float
    ) -> str:
        if abs(forward) < self.DISTANCE_TOLERANCE_FEET and abs(rotation) < self.ANGLE_TOLERANCE_DEGREES:
            return "ALIGNED - Hold position"

        parts = []
        if abs(rotation) > self.ANGLE_TOLERANCE_DEGREES:
            parts.append(
                f"ROTATE {abs(rotation):.1f}° {'RIGHT' if rotation > 0 else 'LEFT'}"
            )

        if abs(forward) > self.DISTANCE_TOLERANCE_FEET:
            parts.append(
                f"DRIVE {abs(forward):.2f} ft {'BACKWARD' if forward > 0 else 'FORWARD'}"
            )
        else:
            parts.append("HOLD DISTANCE")

        if abs(strafe) > 0.1:
            parts.append(
                f"STRAFE {abs(strafe):.2f} ft {'RIGHT' if strafe > 0 else 'LEFT'}"
            )

        return " → ".join(parts)

    def check_alignment(self, forward_error: float, rotation_error: float) -> bool:
        return abs(forward_error) < self.DISTANCE_TOLERANCE_FEET and abs(
            rotation_error
        ) < self.ANGLE_TOLERANCE_DEGREES

    def estimate_pose(self) -> Optional[Pose2d]:
        if self.tag_id == -1 or not self.is_corners_valid():
            return None
        if self.tag_id not in self.tag_layout:
            return None

        tag_x, tag_y, tag_rot_deg = self.tag_layout[self.tag_id]
        tag_pose = Pose2d(Translation2d(tag_x, tag_y), Rotation2d.from_degrees(tag_rot_deg))

        real_time_ta = self.calculate_tag_area()
        camera_distance = self.calculate_distance_from_area(real_time_ta)

        camera_offset_distance = math.hypot(
            self.CAMERA_OFFSET_X_INCHES / 12.0, self.CAMERA_OFFSET_Y_INCHES / 12.0
        )

        horizontal_angle_error = self.tx
        adjusted_camera_distance = camera_distance / math.cos(
            math.radians(self.CAMERA_MOUNT_ANGLE_Y_DEGREES)
        )

        robot_center_distance = math.sqrt(
            math.pow(adjusted_camera_distance, 2)
            + math.pow(camera_offset_distance, 2)
            - 2
            * adjusted_camera_distance
            * camera_offset_distance
            * math.cos(
                math.radians(
                    horizontal_angle_error + self.CAMERA_MOUNT_ANGLE_X_DEGREES
                )
            )
        )

        current_distance = robot_center_distance + 1.0
        distance_meters = current_distance * 0.3048

        robot_angle_to_tag = tag_pose.get_rotation().get_degrees() + 180 - horizontal_angle_error
        robot_rotation = Rotation2d.from_degrees(robot_angle_to_tag)

        angle_rad = math.radians(robot_angle_to_tag)
        robot_x = tag_pose.get_x() - distance_meters * math.cos(angle_rad)
        robot_y = tag_pose.get_y() - distance_meters * math.sin(angle_rad)

        return Pose2d(Translation2d(robot_x, robot_y), robot_rotation)

    def step(self) -> Dict[str, float]:
        """
        Pulls fresh data from network tables and returns movement + pose info.
        """
        self.update_from_networktables()
        if not self.is_corners_valid():
            return {"status": "no_corners"}

        movement = self.calculate_optimal_movement()
        command = self.generate_movement_command(
            movement["forward_feet"],
            movement["strafe_feet"],
            movement["rotation_deg"],
        )
        aligned = self.check_alignment(
            movement["forward_feet"], movement["rotation_deg"]
        )

        pose = self.estimate_pose()
        if pose:
            movement.update(
                {
                    "pose_x_m": pose.get_x(),
                    "pose_y_m": pose.get_y(),
                    "pose_rot_deg": pose.get_rotation().get_degrees(),
                }
            )

        movement.update({"command": command, "aligned": aligned, "tag_id": self.tag_id})
        return movement
